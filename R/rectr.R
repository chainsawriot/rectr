.dl_fasttext <- function(lang = "en") {
    download.file(paste0("https://dl.fbaipublicfiles.com/fasttext/vectors-aligned/wiki.", lang, ".align.vec"), destfile = paste0("wiki.", lang, ".align.vec"), method = 'curl')
}

#' Download fastText word embeddings from the internet
#'
#' This function downloads fastText word embeddings from the internet, trims the embeddings and saves as an R serialized object.
#' @param lang character, which language of fastText word embeddings to download, e.g. "en"
#' @param topwords integer, trim the word embeddings based on the most frequent words, default to top 200000 words
#' @return Nothing, a file is saved.
#' @export
get_ft <- function(lang = "en", topwords = 200000) {
    .dl_fasttext(lang)
    system(paste0("grep -v '^[[:punct:][:digit:]]' wiki.", lang ,".align.vec > wiki.", lang, ".clean.vec"))
    readr::read_delim(paste0("wiki.", lang, ".clean.vec"), col_names = FALSE, skip = 1, delim = " ") %>% head(topwords) %>% saveRDS(paste0("wiki.", lang, ".trimmed.RDS"))
    unlink(paste0("wiki.", lang, ".align.vec"))
    unlink(paste0("wiki.", lang, ".clean.vec"))
}

#' Reading word embeddings downloaded with get_ft()
#'
#' This function reads fastText word embeddings downloaded with get_ft(). The file(s) must be in the working directory.
#' @param lang a vector of languages, e.g. c("en", "de")
#' @return a list of word embeddings
#' @export
read_ft <- function(lang = c("en", "de", "fr")) {
    emb <- purrr::map(lang, ~readRDS(paste0("wiki.", ., ".trimmed.RDS")))
    names(emb) <- lang
    return(emb)
}

#' Create a multilingual corpus
#'
#' This function generates a multilingual corpus.
#' @param text_content a vector of text content
#' @param lang a vector of lang, using lower case, e.g. "de"
#' @return a quanteda corpus
#' @export
create_corpus <- function(text_content, lang) {
    quanteda::corpus(text_content, docvars = data.frame(lang = lang, stringsAsFactors = FALSE))
}

.tokenize <- function(text) {
    return(stringr::str_split(tolower(text), "[[:punct:][:space:]]")[[1]])
}

.gen_doc_embedding <- function(text_content, lang,  emb, boe = FALSE) {
    splited_word <- .tokenize(text_content)
    candidate_words <- tibble::tibble(X1 = splited_word)
    bag_of_embeddings <- candidate_words %>% dplyr::left_join(emb[[lang]], by = "X1") %>% dplyr::filter(X1 != "") %>% dplyr::filter(!X1 %in% quanteda::stopwords(lang))
    if (boe) {
        return(bag_of_embeddings)
    }
    bag_of_embeddings %>% dplyr::summarise_at(dplyr::vars(X2:X301), mean, na.rm = TRUE)
}

#' Generate a document-feature matrix using word embeddings
#'
#' This function generates document-feature matrix (dfm) from a multilingual corpus.
#' @param corpus a multilingual corpus generated by create_corpus()
#' @param emb a list of word embeddings loaded from read_ft()
#' @param .progress boolean, displaying a progress bar or not
#' @return a rectr_dfm object
#' @importFrom magrittr %>%
#' @export
dfm_boe <- function(corpus, emb, .progress = TRUE) {
    future:::plan(future::multiprocess)
    furrr::future_map2_dfr(corpus$documents$texts, corpus$documents$lang, .gen_doc_embedding, emb = emb, .progress = .progress) %>% as.matrix -> real_dfm
    res <- list(dfm = real_dfm, corpus = corpus)
    class(res) <- append(class(res), "rectr_dfm")
    return(res)
}

#' Print a rectr_dfm object
#'
#' This function prints useful information from an rectr_dfm object.
#' @param rectr_dfm a rectr_dfm object
#' @return nothing
#' @export
print.rectr_dfm <- function(rectr_dfm) {
    cat(paste0("dfm with a dimension of ", nrow(rectr_dfm$dfm), " x ", ncol(rectr_dfm$dfm), " and ", paste0(unique(rectr_dfm$corpus$documents$lang), collapse = "/"), " language(s).\n"))
}

.check_lang_indep <- function(lsa_res, lang_vector, alpha = 0.05) {
    max_i <- ncol(lsa_res)
    for (i in 1:max_i) {
        p <- summary(aov(lsa_res[,i]~lang_vector))[[1]]$`Pr(>F)`[1]
        if (p > alpha) {
            return(i)
        }
    }
}


.calculate_rectr <- function(lsa_res, k, corpus, seed) {
    if (!is.null(seed)) {
        set.seed(seed)
    }
    lang_vector <- corpus$documents$lang
    i <- .check_lang_indep(lsa_res, lang_vector)
    max_d <- (k*2) + i
    x <- flexmix::flexmix(lsa_res[,i:max_d]~1, k = k, model = flexmix::FLXMCmvnorm(diagonal = FALSE))
    return(x)
}

#' Filter a document-feature matrix for systematic language differences
#'
#' This function filters a document-feature matrix using singular value decomposition.
#' @param input_dfm dfm generated by dfm_boe()
#' @param dimension integer, the first singular value extracted.
#' @return an rectr_dfm object
#' @export
dfm_filtering <- function(input_dfm, dimension = 100) {
    input_dfm$dfm <- RSpectra::svds(input_dfm$dfm, k = dimension, nu = dimension, nv = dimension)$u
    return(input_dfm)
}

#' Fit a Guassian Mixture Model from a document-feature matrix
#'
#' This function fits a guassian mixture model (GMM) from a document-feature matrix.
#' @param input_dfm a rectr_dfm object
#' @param k integer, number of topics
#' @param seed integer, to set the random seed for reproducibility. When leave as NULL, no random seed is set.
#' @return a rectr_model object. rectr_model$theta is the topic-assignment matrix
#' @export
calculate_gmm <- function(input_dfm, k = 5, seed = NULL) {
    gmm_model <- .calculate_rectr(input_dfm$dfm, k = k, corpus = input_dfm$corpus, seed = seed)
    res <- list()
    res$gmm_model <- gmm_model
    res$dfm <- input_dfm
    res$theta <- flexmix::posterior(gmm_model)
    res$k <- k
    res$seed <- seed
    class(res) <- append(class(res), "rectr_model")
    return(res)
}

#' Print a rectr_model object
#'
#' Print useful information about a rectr_model.
#' @param rectr_model a rectr_model object
#' @return nothing
#' @export
print.rectr_model <- function(rectr_model) {
    cat(paste0(rectr_model$k, "-topic rectr model trained with a "))
    print(rectr_model$dfm)
}
